#! /usr/bin/python3 -tt

# paperwork

# Copyright 2012-2019 Richard Fearn
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

BATCH_SIZE = 20

PROGRAM_NAME = "paperwork"

from requests_oauthlib import OAuth1
import requests
import urllib.parse
import datetime
import sys
import argparse
import getpass
import fnmatch

import paperwork

RED       = "\033[1;31m"
GREEN     = "\033[1;32m"
NO_COLOUR = "\033[0m"

USAGE = """
usage: %(red)s%(progname)s%(nocolour)s <action> <action args>

where <action> can be:

%(green)sfolders%(nocolour)s
    show list of folders

%(green)sarticles%(nocolour)s
    dump URLs of all articles in all folders

%(green)scount%(nocolour)s
    show list of folders (including unread) with article count

%(green)sexport%(nocolour)s
    dump folders and articles as XML

%(green)sbatch%(nocolour)s
    move max. 20 articles into a folder named with today's date

%(green)semptyfolder%(nocolour)s <folder name>
    delete articles in the specified folder

%(green)swipefolder%(nocolour)s <folder name>
    delete articles in the specified folder, and delete the folder

%(green)sfoldertotop%(nocolour)s <folder name>
    move a folder to the top of the folder list

%(green)sauth/authenticate%(nocolour)s -u <username>
    authenticate as the specified user

%(green)sunauth/unauthenticate%(nocolour)s -u <username>
    remove authentication tokens for the specified user
""" % {"progname": PROGRAM_NAME, "red": RED, "green": GREEN, "nocolour": NO_COLOUR}

################################################################################

parser = argparse.ArgumentParser()
parser.add_argument("-n", "--dry-run", action="store_true", default=False, help="perform a trial run")
parser.add_argument("-q", "--quiet",   action="store_true", default=False, help="suppress non-error messages")
parser.add_argument("-u", "--username", help="username")
(options, args) = parser.parse_known_args()

if len(args) == 0:
    print(USAGE, file=sys.stderr)
    sys.exit(1)

command = args[0]

################################################################################

config = paperwork.Config()

# add [paperwork] section, if missing
# if not config.has_section(PAPERWORK_SECTION):
#     config.add_section(PAPERWORK_SECTION)
#     save_config(config)

# key_or_secret_missing = False

# if not config.has_option(PAPERWORK_SECTION, "consumer_key"):
#     key_or_secret_missing = True

# if not config.has_option(PAPERWORK_SECTION, "consumer_secret"):
#     key_or_secret_missing = True

# if key_or_secret_missing:
#     print >>sys.stderr, "%s: consumer key or secret missing in .paperworkrc file" % PROGRAM_NAME
#     sys.exit(1)

################################################################################

if command in ("auth", "authenticate"):

    if not options.username:
        print("%s: no username provided" % PROGRAM_NAME, file=sys.stderr)
        sys.exit(1)

    if config.has_credentials(options.username):
        print("%s: %s already authenticated" % (PROGRAM_NAME, options.username), file=sys.stderr)
        sys.exit(1)

    prompt = "enter password for %s: " % options.username
    password = getpass.getpass(prompt=prompt)

    auth_client = OAuth1(config.consumer_key(), client_secret=config.consumer_secret())

    response = requests.post(
        url=paperwork.client.API_URL_PREFIX + paperwork.client.OAUTH_ACCESS_TOKEN,
        params={
            "x_auth_mode": "client_auth",
            "x_auth_username": options.username,
            "x_auth_password": password,
        },
        auth=auth_client
    )

    if response.status_code in (400, 401):
        print("%s: incorrect password" % PROGRAM_NAME, file=sys.stderr)
        sys.exit(1)

    elif response.status_code != 200:
        print("%s: invalid response (%s)" % (PROGRAM_NAME, response.status_code), file=sys.stderr)
        sys.exit(1)

    if not options.quiet:
        print("%s successfully authenticated" % options.username)

    token = dict(urllib.parse.parse_qsl(response.text))
    (token, token_secret) = (token["oauth_token"], token["oauth_token_secret"])

    # add token/secret to config
    config.add_credentials(options.username, token, token_secret)

    sys.exit(0)

################################################################################

# all the following commands require an account, so complain if there aren't any
# accounts = [n for n in config.sections() if n != PAPERWORK_SECTION]
# if not accounts:
#     print >>sys.stderr, "%s: no accounts" % PROGRAM_NAME
#     sys.exit(1)

# find a default username, if no username was specified
# if not options.username:
#     options.username = accounts[0]

options.username = "richardfearn@gmail.com"  # TODO

################################################################################

if command in ("unauth", "unauthenticate"):

    if not options.username:
        print("%s: no username provided" % PROGRAM_NAME, file=sys.stderr)
        sys.exit(1)

    if not config.has_credentials(options.username):
        print("%s: unknown username %s" % (PROGRAM_NAME, options.username), file=sys.stderr)
        sys.exit(1)

    # remove token/secret from config
    config.remove_credentials(options.username)

    sys.exit(0)

################################################################################

client = paperwork.Client(config, options.username)

################################################################################

if command == "folders":
    folders = client.list_folders()
    for f in folders:
        print(f.title)

################################################################################

if command == "articles":
    folders = client.list_folders()
    folders.insert(0, paperwork.UNREAD_FOLDER)
    for f in folders:
        bookmarks = client.list_bookmarks(f)
        for b in bookmarks:
            print(b.url)

################################################################################

def matching_folders(folders, patterns):

    folders_by_name = dict((f.title, f) for f in folders)
    folder_names = [f.title for f in folders]

    matching_folder_names = []
    for p in patterns:
        matches = fnmatch.filter(folder_names, p)
        matching_folder_names.extend(matches)

    matching_folders = [folders_by_name[f] for f in matching_folder_names]

    return matching_folders

################################################################################

if command == "count":
    try:
        folders = client.list_folders()
        folders.insert(0, paperwork.UNREAD_FOLDER)
        specified_folders = args[1:]
        if specified_folders:
            folders = matching_folders(folders, specified_folders)
            show_total = False
        else:
            show_total = True
        total = 0
        for f in folders:
            bookmarks = client.list_bookmarks(f)
            print("%d\t%s" % (len(bookmarks), f.title))
            total += len(bookmarks)
            sys.stdout.flush()
        if show_total:
            print("-" * 30)
            print("%d\tTOTAL" % total)
    except KeyboardInterrupt:
        pass

################################################################################

if command == "export":
    from xml.dom.minidom import getDOMImplementation
    impl = getDOMImplementation()
    newdoc = impl.createDocument(None, "bookmarks", None)
    top_element = newdoc.documentElement

    specified_folders = args[1:]

    folders = client.list_folders()
    folders.insert(0, paperwork.ARCHIVE_FOLDER)
    folders.insert(0, paperwork.UNREAD_FOLDER)

    if not specified_folders:
        folders_to_export = folders
    else:
        folders_to_export = matching_folders(folders, specified_folders)

    for f in folders_to_export:
        print(f.title, file=sys.stderr)
        folder_el = newdoc.createElement("folder")
        folder_el.setAttribute("id", str(f.id))
        folder_el.setAttribute("title", f.title)
        top_element.appendChild(folder_el)
        bookmarks = client.list_bookmarks(f)
        bookmark_time_and_id = lambda b: (b.time, b.id)
        bookmarks.sort(key=bookmark_time_and_id, reverse=True)
        for b in bookmarks:
            bookmark_el = newdoc.createElement("bookmark")
            bookmark_el.setAttribute("id", str(b.id))
            bookmark_el.setAttribute("time", str(b.time))
            bookmark_el.setAttribute("url", b.url)
            bookmark_el.setAttribute("title", b.title)
            folder_el.appendChild(bookmark_el)
    print(newdoc.toprettyxml())

################################################################################

if command == "batch":

    if len(args) == 2:
        foldername = args[1]
    else:
        foldername = "unread"

    # get folders
    folders = client.list_folders()
    folders = dict([(f.title, f) for f in folders])
    folders["unread"] = paperwork.UNREAD_FOLDER

    # check specified folder exists
    if foldername not in folders:
        print("%s: unknown folder '%s'" % (PROGRAM_NAME, foldername), file=sys.stderr)
        sys.exit(1)

    folder = folders[foldername]

    # get bookmarks in folder
    bookmarks = client.list_bookmarks(folder)

    # exit if there are no bookmarks to batch
    if len(bookmarks) == 0:
        print("%s: no bookmarks to batch" % PROGRAM_NAME, file=sys.stderr)
        sys.exit(1)

    if not options.quiet:
        print("%d bookmark(s) in '%s' folder" % (len(bookmarks), foldername))

    # get list of current folder names
    folders = client.list_folders()
    folder_names = [f.title for f in folders]

    if len(args) == 2:
        new_folder_prefix = foldername
    else:
        now = datetime.datetime.now()
        new_folder_prefix = now.strftime("%Y-%m-%d")

    # determine name for new folder
    letter = "a"
    while (new_folder_prefix + "-" + letter) in folder_names:
        letter = chr(ord(letter) + 1)
    new_folder_name = new_folder_prefix + "-" + letter

    # create new folder

    if not options.quiet:
        print("adding new folder '%s'" % new_folder_name)
    if not options.dry_run:
        new_folder = paperwork.Folder(title=new_folder_name)
        new_folder = client.add_folder(new_folder)
        if not options.quiet:
            print("done (folder_id=%s)" % new_folder.id)

    # move 20 oldest bookmarks into new folder
    bookmarks = list(reversed(bookmarks))
    bookmarks_to_move = bookmarks[0:BATCH_SIZE]
    for (i, b) in enumerate(bookmarks_to_move):
        if not options.quiet:
            print("moving (%d of %d): %s" % (i+1, len(bookmarks_to_move), b.title))
        if not options.dry_run:
            client.move_bookmark(b, new_folder)

    if not options.quiet:
        print("%d bookmark(s) remaining in '%s' folder" % (len(bookmarks) - len(bookmarks_to_move), foldername))
        print("done")

################################################################################

if command == "emptyfolder":

    foldername = args[1]

    # get folders
    folders = client.list_folders()
    folders = dict([(f.title, f) for f in folders])
    folders["unread"] = paperwork.UNREAD_FOLDER

    # check specified folder exists
    if foldername not in folders:
        print("%s: unknown folder '%s'" % (PROGRAM_NAME, foldername), file=sys.stderr)
        sys.exit(1)

    folder = folders[foldername]

    # get bookmarks in folder
    bookmarks = client.list_bookmarks(folder)

    # delete bookmarks
    for (i, b) in enumerate(bookmarks):
        print("deleting (%d of %d): %s" % (i+1, len(bookmarks), b.title))
        if not options.dry_run:
            client.delete_bookmark(b)

    print("done")

################################################################################

if command == "wipefolder":

    foldername = args[1]

    # get folders
    folders = client.list_folders()
    folders = dict([(f.title, f) for f in folders])

    # check specified folder exists
    if foldername not in folders:
        print("%s: unknown folder '%s'" % (PROGRAM_NAME, foldername),file=sys.stderr)
        sys.exit(1)

    folder = folders[foldername]

    # get bookmarks in folder
    bookmarks = client.list_bookmarks(folder)

    # delete bookmarks
    for (i, b) in enumerate(bookmarks):
        print("deleting (%d of %d): %s" % (i+1, len(bookmarks), b.title))
        if not options.dry_run:
            client.delete_bookmark(b)

    # delete folder
    print("deleting folder '%s'" % foldername)
    if not options.dry_run:
        client.delete_folder(folder)

    print("done")

################################################################################

if command == "foldertotop":

    foldername = args[1]

    # get folders
    folders = client.list_folders()

    # check specified folder exists
    folder_names = [f.title for f in folders]
    if foldername not in folder_names:
        print("%s: unknown folder '%s'" % (PROGRAM_NAME, foldername), file=sys.stderr)
        sys.exit(1)

    # determine new position for each folder
    order = []
    folder_pos = 1
    for f in folders:
        folder_name = f.id
        position = f.position
        if f.title == foldername:
            position = 1
        else:
            folder_pos += 1
            position = folder_pos
        order.append((folder_name, position))
    order = ["%d:%d" % p for p in order]
    order = ",".join(order)

    # send the reorder request
    if not options.dry_run:
        client._do_request(paperwork.client.SET_FOLDER_ORDER, {"order": order})

################################################################################

if command == "mkdir":

    folder_name = args[1]

    new_folder = paperwork.Folder(title=folder_name)
    client.add_folder(new_folder)
